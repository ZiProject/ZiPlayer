// Auto-generated API content
// Do not edit this file manually - it will be overwritten

export const generatedApiContent = {
	playermanager: {
		title: "PlayerManager",
		description: "The main class for managing players across multiple Discord guilds.",
		summary: "",
		badges: ["class", "core", "playermanager"],
		code: '// Basic setup with plugins and extensions\nconst manager = new PlayerManager({\n  plugins: [\n    new YouTubePlugin(),\n    new SoundCloudPlugin(),\n    new SpotifyPlugin(),\n    new TTSPlugin({ defaultLang: "en" })\n  ],\n  extensions: [\n    new voiceExt(null, { lang: "en-US" }),\n    new lavalinkExt(null, {\n      nodes: [{ host: "localhost", port: 2333, password: "youshallnotpass" }]\n    })\n  ],\n  extractorTimeout: 10000\n});\n// Create a player for a guild\nconst player = await manager.create(guildId, {\n  tts: { interrupt: true, volume: 1 },\n  leaveOnEnd: true,\n  leaveTimeout: 30000\n});\n// Get existing player\nconst existingPlayer = manager.get(guildId);\nif (existingPlayer) {\n  await existingPlayer.play("Never Gonna Give You Up", userId);\n}',
		methods: [
			{
				name: "create",
				signature: "async create(guildOrId: string | { id: string }, options?: PlayerOptions): Promise<Player>",
				description: "Create a new player for a guild",
				example:
					'// Create player with basic options\nconst player = await manager.create(guildId, {\n  tts: { interrupt: true, volume: 1 },\n  leaveOnEnd: true,\n  leaveTimeout: 30000\n});\n// Create player with advanced options\nconst advancedPlayer = await manager.create(guild, {\n  volume: 0.8,\n  quality: "high",\n  selfDeaf: false,\n  selfMute: false,\n  tts: {\n    createPlayer: true,\n    interrupt: true,\n    volume: 1.0,\n    Max_Time_TTS: 30000\n  },\n  userdata: { customData: "example" }\n});\n// Connect and play immediately\nawait player.connect(voiceChannel);\nawait player.play("Never Gonna Give You Up", userId);\n/',
				code: '// Create player with basic options\nconst player = await manager.create(guildId, {\n  tts: { interrupt: true, volume: 1 },\n  leaveOnEnd: true,\n  leaveTimeout: 30000\n});\n// Create player with advanced options\nconst advancedPlayer = await manager.create(guild, {\n  volume: 0.8,\n  quality: "high",\n  selfDeaf: false,\n  selfMute: false,\n  tts: {\n    createPlayer: true,\n    interrupt: true,\n    volume: 1.0,\n    Max_Time_TTS: 30000\n  },\n  userdata: { customData: "example" }\n});\n// Connect and play immediately\nawait player.connect(voiceChannel);\nawait player.play("Never Gonna Give You Up", userId);',
				parameters: [
					{
						name: "guildOrId",
						type: "string | { id: string }",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "options?",
						type: "PlayerOptions",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Promise<Player>",
					description: "The created player instance",
				},
			},
			{
				name: "get",
				signature: "get(guildOrId: string | { id: string }): Player | undefined",
				description: "Get an existing player for a guild",
				example:
					'// Get player by guild ID\nconst player = manager.get(guildId);\nif (player) {\n  await player.play("Never Gonna Give You Up", userId);\n} else {\n  console.log("No player found for this guild");\n}\n// Get player by guild object\nconst playerFromGuild = manager.get(guild);\nif (playerFromGuild) {\n  playerFromGuild.setVolume(0.5);\n}\n// Check if player exists before using\nconst existingPlayer = manager.get(guildId);\nif (existingPlayer && existingPlayer.playing) {\n  existingPlayer.pause();\n}\n/',
				code: '// Get player by guild ID\nconst player = manager.get(guildId);\nif (player) {\n  await player.play("Never Gonna Give You Up", userId);\n} else {\n  console.log("No player found for this guild");\n}\n// Get player by guild object\nconst playerFromGuild = manager.get(guild);\nif (playerFromGuild) {\n  playerFromGuild.setVolume(0.5);\n}\n// Check if player exists before using\nconst existingPlayer = manager.get(guildId);\nif (existingPlayer && existingPlayer.playing) {\n  existingPlayer.pause();\n}',
				parameters: [
					{
						name: "guildOrId",
						type: "string | { id: string }",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Player | undefined",
					description: "The player instance or undefined if not found",
				},
			},
			{
				name: "getPlayer",
				signature: "getPlayer(guildOrId: string | { id: string }): Player | undefined",
				description: "Get an existing player for a guild",
				example: 'const player = manager.get(guildId);\nif (player) {\n  await player.play("song name", userId);\n}\n/',
				code: 'const player = manager.get(guildId);\nif (player) {\n  await player.play("song name", userId);\n}',
				parameters: [
					{
						name: "guildOrId",
						type: "string | { id: string }",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Player | undefined",
					description: "The player instance or undefined",
				},
			},
			{
				name: "getall",
				signature: "getall(): Player[] | []",
				description: "Get all players",
				example: "const players = manager.getall();\nconsole.log(`Players: ${players.length}`);\n/",
				code: "const players = manager.getall();\nconsole.log(`Players: ${players.length}`);",
				parameters: [],
				returns: {
					type: "Player[]",
					description: "All player instances",
				},
			},
			{
				name: "delete",
				signature: "delete(guildOrId: string | { id: string }): boolean",
				description: "Destroy a player and clean up resources",
				example:
					'// Destroy player by guild ID\nconst destroyed = manager.delete(guildId);\nif (destroyed) {\n  console.log("Player destroyed successfully");\n} else {\n  console.log("No player found to destroy");\n}\n// Destroy player by guild object\nconst destroyedFromGuild = manager.delete(guild);\nconsole.log(`Player destroyed: ${destroyedFromGuild}`);\n// Clean up all players\nfor (const [guildId, player] of manager.players) {\n  const destroyed = manager.delete(guildId);\n  console.log(`Destroyed player for ${guildId}: ${destroyed}`);\n}\n/',
				code: '// Destroy player by guild ID\nconst destroyed = manager.delete(guildId);\nif (destroyed) {\n  console.log("Player destroyed successfully");\n} else {\n  console.log("No player found to destroy");\n}\n// Destroy player by guild object\nconst destroyedFromGuild = manager.delete(guild);\nconsole.log(`Player destroyed: ${destroyedFromGuild}`);\n// Clean up all players\nfor (const [guildId, player] of manager.players) {\n  const destroyed = manager.delete(guildId);\n  console.log(`Destroyed player for ${guildId}: ${destroyed}`);\n}',
				parameters: [
					{
						name: "guildOrId",
						type: "string | { id: string }",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "True if player was destroyed, false if not found",
				},
			},
			{
				name: "has",
				signature: "has(guildOrId: string | { id: string }): boolean",
				description: "Check if a player exists for a guild",
				example: "const exists = manager.has(guildId);\nconsole.log(`Player exists: ${exists}`);\n/",
				code: "const exists = manager.has(guildId);\nconsole.log(`Player exists: ${exists}`);",
				parameters: [
					{
						name: "guildOrId",
						type: "string | { id: string }",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "True if player exists, false if not",
				},
			},
			{
				name: "destroy",
				signature: "destroy(): void",
				description: "Destroy all players",
				example: "manager.destroy();\nconsole.log(`All players destroyed`);\n/",
				code: "manager.destroy();\nconsole.log(`All players destroyed`);",
				parameters: [],
				returns: {
					type: "void",
					description: "",
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description: "Search using registered plugins without creating a Player.",
				example:
					'const result = await manager.search("Never Gonna Give You Up", userId);\nconsole.log(`Search result: ${result.tracks.length} tracks`);\n/',
				code: 'const result = await manager.search("Never Gonna Give You Up", userId);\nconsole.log(`Search result: ${result.tracks.length} tracks`);',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Promise<SearchResult>",
					description: "The search result",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	player: {
		title: "Player",
		description: "Represents a music player for a specific Discord guild.",
		summary: "",
		badges: ["class", "core", "player"],
		code: '// Create and configure player\nconst player = await manager.create(guildId, {\n  tts: { interrupt: true, volume: 1 },\n  leaveOnEnd: true,\n  leaveTimeout: 30000\n});\n// Connect to voice channel\nawait player.connect(voiceChannel);\n// Play different types of content\nawait player.play("Never Gonna Give You Up", userId); // Search query\nawait player.play("https://youtube.com/watch?v=dQw4w9WgXcQ", userId); // Direct URL\nawait player.play("tts: Hello everyone!", userId); // Text-to-Speech\n// Player controls\nplayer.pause(); // Pause current track\nplayer.resume(); // Resume paused track\nplayer.skip(); // Skip to next track\nplayer.stop(); // Stop and clear queue\nplayer.setVolume(0.5); // Set volume to 50%\n// Event handling\nplayer.on("trackStart", (player, track) => {\n  console.log(`Now playing: ${track.title}`);\n});\nplayer.on("queueEnd", (player) => {\n  console.log("Queue finished");\n});',
		methods: [
			{
				name: "connect",
				signature: "async connect(channel: VoiceChannel): Promise<VoiceConnection>",
				description: "Connect to a voice channel",
				example: "await player.connect(voiceChannel);\n/",
				code: "await player.connect(voiceChannel);",
				parameters: [
					{
						name: "channel",
						type: "VoiceChannel",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Promise<VoiceConnection>",
					description: "The voice connection",
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description: "Search for tracks using the player's extensions and plugins",
				example:
					'const result = await player.search("Never Gonna Give You Up", userId);\nconsole.log(`Search result: ${result.tracks.length} tracks`);\n/',
				code: 'const result = await player.search("Never Gonna Give You Up", userId);\nconsole.log(`Search result: ${result.tracks.length} tracks`);',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Promise<SearchResult>",
					description: "The search result",
				},
			},
			{
				name: "play",
				signature: "async play(query: string | Track | SearchResult | null, requestedBy?: string): Promise<boolean>",
				description: "Play a track, search query, search result, or play from queue",
				example:
					'await player.play("Never Gonna Give You Up", userId); // Search query\nawait player.play("https://youtube.com/watch?v=dQw4w9WgXcQ", userId); // Direct URL\nawait player.play("tts: Hello everyone!", userId); // Text-to-Speech\nawait player.play(trackObject, userId); // Track object\nawait player.play(searchResult, userId); // SearchResult object\nawait player.play(null); // play from queue\n/',
				code: 'await player.play("Never Gonna Give You Up", userId); // Search query\nawait player.play("https://youtube.com/watch?v=dQw4w9WgXcQ", userId); // Direct URL\nawait player.play("tts: Hello everyone!", userId); // Text-to-Speech\nawait player.play(trackObject, userId); // Track object\nawait player.play(searchResult, userId); // SearchResult object\nawait player.play(null); // play from queue',
				parameters: [
					{
						name: "query",
						type: "string | Track | SearchResult | null",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy?",
						type: "string",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Promise<boolean>",
					description: "True if playback started successfully",
				},
			},
			{
				name: "pause",
				signature: "pause(): boolean",
				description: "Pause the current track",
				example: "const paused = player.pause();\nconsole.log(`Paused: ${paused}`);\n/",
				code: "const paused = player.pause();\nconsole.log(`Paused: ${paused}`);",
				parameters: [],
				returns: {
					type: "boolean",
					description: "True if paused successfully",
				},
			},
			{
				name: "resume",
				signature: "resume(): boolean",
				description: "Resume the current track",
				example: "const resumed = player.resume();\nconsole.log(`Resumed: ${resumed}`);\n/",
				code: "const resumed = player.resume();\nconsole.log(`Resumed: ${resumed}`);",
				parameters: [],
				returns: {
					type: "boolean",
					description: "True if resumed successfully",
				},
			},
			{
				name: "stop",
				signature: "stop(): boolean",
				description: "Stop the current track",
				example: "const stopped = player.stop();\nconsole.log(`Stopped: ${stopped}`);\n/",
				code: "const stopped = player.stop();\nconsole.log(`Stopped: ${stopped}`);",
				parameters: [],
				returns: {
					type: "boolean",
					description: "True if stopped successfully",
				},
			},
			{
				name: "skip",
				signature: "skip(index?: number): boolean",
				description: "Skip to the next track or skip to a specific index",
				example:
					"const skipped = player.skip(); // Skip to next track\nconst skippedToIndex = player.skip(2); // Skip to track at index 2\nconsole.log(`Skipped: ${skipped}`);\n/",
				code: "const skipped = player.skip(); // Skip to next track\nconst skippedToIndex = player.skip(2); // Skip to track at index 2\nconsole.log(`Skipped: ${skipped}`);",
				parameters: [
					{
						name: "index?",
						type: "number",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "True if skipped successfully",
				},
			},
			{
				name: "autoPlay",
				signature: "autoPlay(mode?: boolean): boolean",
				description: "Set the auto-play mode",
				example: "const autoPlayMode = player.autoPlay(true);\nconsole.log(`Auto-play mode: ${autoPlayMode}`);\n/",
				code: "const autoPlayMode = player.autoPlay(true);\nconsole.log(`Auto-play mode: ${autoPlayMode}`);",
				parameters: [
					{
						name: "mode?",
						type: "boolean",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "The auto-play mode",
				},
			},
			{
				name: "setVolume",
				signature: "setVolume(volume: number): boolean",
				description: "Set the volume of the current track",
				example: "const volumeSet = player.setVolume(50);\nconsole.log(`Volume set: ${volumeSet}`);\n/",
				code: "const volumeSet = player.setVolume(50);\nconsole.log(`Volume set: ${volumeSet}`);",
				parameters: [
					{
						name: "volume",
						type: "number",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "True if volume was set successfully",
				},
			},
			{
				name: "shuffle",
				signature: "shuffle(): void",
				description: "Shuffle the queue",
				example: "player.shuffle();\n/",
				code: "player.shuffle();",
				parameters: [],
				returns: {
					type: "void",
					description: "",
				},
			},
			{
				name: "remove",
				signature: "remove(index: number): Track | null",
				description: "Remove a track from the queue",
				example: "const removed = player.remove(0);\nconsole.log(`Removed: ${removed?.title}`);\n/",
				code: "const removed = player.remove(0);\nconsole.log(`Removed: ${removed?.title}`);",
				parameters: [
					{
						name: "index",
						type: "number",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Track | null",
					description: "The removed track or null",
				},
			},
			{
				name: "destroy",
				signature: "destroy(): void",
				description: "Destroy the player",
				example: "player.destroy();\n/",
				code: "player.destroy();",
				parameters: [],
				returns: {
					type: "void",
					description: "",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	queue: {
		title: "Queue",
		description: "Manages the track queue for a player.",
		summary: "",
		badges: ["class", "core", "queue"],
		code: '// Basic queue operations\nconst queue = player.queue;\n// Add single track\nqueue.add(track);\n// Add multiple tracks\nqueue.add([track1, track2, track3]);\n// Queue controls\nqueue.shuffle(); // Randomize order\nqueue.clear(); // Remove all tracks\nqueue.autoPlay(true); // Enable auto-play\n// Get queue information\nconsole.log(`Queue length: ${queue.length}`);\nconsole.log(`Current track: ${queue.current?.title}`);\nconsole.log(`Is empty: ${queue.isEmpty}`);\nconsole.log(`Is playing: ${queue.isPlaying}`);\n// Loop modes\nqueue.setLoopMode("track"); // Loop current track\nqueue.setLoopMode("queue"); // Loop entire queue\nqueue.setLoopMode("off"); // No loop\n// Remove specific track\nconst removed = queue.remove(0); // Remove first track\nif (removed) {\n  console.log(`Removed: ${removed.title}`);\n}',
		methods: [
			{
				name: "add",
				signature: "add(track: Track): void",
				description: "Add track(s) to the queue",
				example: "queue.add(track);\nqueue.add([track1, track2, track3]);\n/",
				code: "queue.add(track);\nqueue.add([track1, track2, track3]);",
				parameters: [
					{
						name: "track",
						type: "Track",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: "void",
			},
			{
				name: "remove",
				signature: "remove(index: number): Track | null",
				description: "Remove a track from the queue",
				example: "const removed = queue.remove(0);\nconsole.log(`Removed: ${removed?.title}`);\n/",
				code: "const removed = queue.remove(0);\nconsole.log(`Removed: ${removed?.title}`);",
				parameters: [
					{
						name: "index",
						type: "number",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "Track | null",
					description: "Removed track or null",
				},
			},
			{
				name: "clear",
				signature: "clear(): void",
				description: "Clear all tracks from the queue",
				example: "queue.clear();\n/",
				code: "queue.clear();",
				parameters: [],
				returns: "void",
			},
			{
				name: "autoPlay",
				signature: "autoPlay(value?: boolean): boolean",
				description: "Enable or disable auto-play",
				example: "queue.autoPlay(true);\nqueue.autoPlay(); // Get current auto-play state\n/",
				code: "queue.autoPlay(true);\nqueue.autoPlay(); // Get current auto-play state",
				parameters: [
					{
						name: "value?",
						type: "boolean",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "boolean",
					description: "Current auto-play state",
				},
			},
			{
				name: "shuffle",
				signature: "shuffle(): void",
				description: "Shuffle the queue",
				example: "queue.shuffle();\n/",
				code: "queue.shuffle();",
				parameters: [],
				returns: "void",
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	track: {
		title: "Track",
		description: "Represents a music track with metadata and streaming information.",
		summary: "",
		badges: ["interface", "core", "track"],
		code: '// Basic track from YouTube\nconst track: Track = {\n  id: "dQw4w9WgXcQ",\n  title: "Never Gonna Give You Up",\n  url: "https://youtube.com/watch?v=dQw4w9WgXcQ",\n  duration: 212000,\n  thumbnail: "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg",\n  requestedBy: "123456789",\n  source: "youtube",\n  metadata: {\n    artist: "Rick Astley",\n    album: "Whenever You Need Somebody"\n  }\n};\n// Track from SoundCloud\nconst soundcloudTrack: Track = {\n  id: "soundcloud-track-123",\n  title: "Electronic Song",\n  url: "https://soundcloud.com/artist/electronic-song",\n  duration: 180000,\n  requestedBy: "user456",\n  source: "soundcloud",\n  metadata: {\n    artist: "Electronic Artist",\n    genre: "Electronic"\n  }\n};\n// TTS track\nconst ttsTrack: Track = {\n  id: "tts-" + Date.now(),\n  title: "TTS: Hello everyone!",\n  url: "tts: Hello everyone!",\n  duration: 5000,\n  requestedBy: "user789",\n  source: "tts",\n  metadata: {\n    text: "Hello everyone!",\n    language: "en"\n  }\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	searchresult: {
		title: "SearchResult",
		description: "Contains search results from plugins, including tracks and optional playlist information.",
		summary: "",
		badges: ["interface", "core", "searchresult"],
		code: 'const result: SearchResult = {\n  tracks: [\n    {\n      id: "track1",\n      title: "Song 1",\n      url: "https://example.com/track1",\n      duration: 180000,\n      requestedBy: "user123",\n      source: "youtube"\n    }\n  ],\n  playlist: {\n    name: "My Playlist",\n    url: "https://example.com/playlist",\n    thumbnail: "https://example.com/thumb.jpg"\n  }\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	streaminfo: {
		title: "StreamInfo",
		description: "Contains streaming information for audio playback.",
		summary: "",
		badges: ["interface", "core", "streaminfo"],
		code: 'const streamInfo: StreamInfo = {\n  stream: audioStream,\n  type: "webm/opus",\n  metadata: {\n    bitrate: 128000,\n    sampleRate: 48000\n  }\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	playeroptions: {
		title: "PlayerOptions",
		description: "Configuration options for creating a new player instance.",
		summary: "",
		badges: ["interface", "core", "playeroptions"],
		code: 'const options: PlayerOptions = {\n  leaveOnEnd: true,\n  leaveOnEmpty: true,\n  leaveTimeout: 30000,\n  volume: 0.5,\n  quality: "high",\n  selfDeaf: false,\n  selfMute: false,\n  extractorTimeout: 10000,\n  tts: {\n    createPlayer: true,\n    interrupt: true,\n    volume: 1.0,\n    Max_Time_TTS: 30000\n  }\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	playermanageroptions: {
		title: "PlayerManagerOptions",
		description: "Configuration options for creating a PlayerManager instance.",
		summary: "",
		badges: ["interface", "core", "playermanageroptions"],
		code: 'const managerOptions: PlayerManagerOptions = {\n  plugins: [\n    new YouTubePlugin(),\n    new SoundCloudPlugin(),\n    new SpotifyPlugin(),\n    new TTSPlugin({ defaultLang: "en" })\n  ],\n  extensions: [\n    new voiceExt(null, { lang: "en-US" }),\n    new lavalinkExt(null, { nodes: [...] })\n  ],\n  extractorTimeout: 10000\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	progressbaroptions: {
		title: "ProgressBarOptions",
		description: "Options for the progress bar",
		summary: "",
		badges: ["interface", "core", "progressbaroptions"],
		code: 'const options: ProgressBarOptions = {\n  size: 10,\n  barChar: "=",\n  progressChar: ">"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensioncontext: {
		title: "ExtensionContext",
		description: "Context for the extension",
		summary: "",
		badges: ["interface", "extension", "extensioncontext"],
		code: "const context: ExtensionContext = {\n  player: player,\n  manager: manager\n};",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensionplayrequest: {
		title: "ExtensionPlayRequest",
		description: "Request for the extension to play a track",
		summary: "",
		badges: ["interface", "extension", "extensionplayrequest"],
		code: 'const request: ExtensionPlayRequest = {\n  query: "Song Name",\n  requestedBy: "user123"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensionplayresponse: {
		title: "ExtensionPlayResponse",
		description: "Response for the extension to play a track",
		summary: "",
		badges: ["interface", "extension", "extensionplayresponse"],
		code: 'const response: ExtensionPlayResponse = {\n  handled: true,\n  query: "Song Name",\n  requestedBy: "user123"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensionafterplaypayload: {
		title: "ExtensionAfterPlayPayload",
		description: "Payload for the extension to play a track",
		summary: "",
		badges: ["interface", "extension", "extensionafterplaypayload"],
		code: 'const payload: ExtensionAfterPlayPayload = {\n  success: true,\n  query: "Song Name",\n  requestedBy: "user123"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensionstreamrequest: {
		title: "ExtensionStreamRequest",
		description: "Request for the extension to stream a track",
		summary: "",
		badges: ["interface", "extension", "extensionstreamrequest"],
		code: "const request: ExtensionStreamRequest = {\n  track: track\n};",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	extensionsearchrequest: {
		title: "ExtensionSearchRequest",
		description: "Request for the extension to search for a track",
		summary: "",
		badges: ["interface", "extension", "extensionsearchrequest"],
		code: 'const request: ExtensionSearchRequest = {\n  query: "Song Name",\n  requestedBy: "user123"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	playerevents: {
		title: "PlayerEvents",
		description: "The PlayerEvents interface",
		summary: "",
		badges: ["interface", "core", "playerevents"],
		code: "// PlayerEvents usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
	},
	sourceplugin: {
		title: "SourcePlugin",
		description: "Plugin interface",
		summary: "",
		badges: ["interface", "plugin", "sourceplugin"],
		code: 'const plugin: SourcePlugin = {\n  name: "YouTube",\n  version: "1.0.0"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	sourceextension: {
		title: "SourceExtension",
		description: "Extension interface",
		summary: "",
		badges: ["interface", "extension", "sourceextension"],
		code: 'const extension: SourceExtension = {\n  name: "YouTube",\n  version: "1.0.0"\n};',
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	lavalinkext: {
		title: "lavalinkExt",
		description:
			"Lavalink extension for ZiPlayer that provides high-performance audio streaming. This extension integrates with Lavalink nodes to provide: - High-quality audio streaming with low latency - Advanced audio processing and effects - Load balancing across multiple Lavalink nodes - WebSocket-based real-time player updates - Automatic failover and reconnection - Voice connection management",
		summary: "",
		badges: ["class", "extension", "lavalinkext"],
		code: 'const lavalinkExt = new lavalinkExt(null, {\n  nodes: [\n    { host: "localhost", port: 2333, password: "youshallnotpass" }\n  ],\n  clientName: "MyBot",\n  userId: "123456789"\n});\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  extensions: [lavalinkExt]\n});',
		methods: [
			{
				name: "active",
				signature: "async active(alas: any): Promise<boolean>",
				description:
					"Activates the extension with the provided context. This method is called when the extension is activated and handles: - Setting up the player manager reference - Binding the Discord client for voice events - Attaching to the player instance - Initializing Lavalink node connections",
				example:
					"const success = await lavalinkExt.active({\n  manager: playerManager,\n  client: discordClient,\n  player: playerInstance\n});\n/",
				code: "const success = await lavalinkExt.active({\n  manager: playerManager,\n  client: discordClient,\n  player: playerInstance\n});",
				parameters: [
					{
						name: "alas",
						type: "any",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if activation was successful, `false` otherwise",
				},
			},
			{
				name: "onRegister",
				signature: "onRegister(context: ExtensionContext): void",
				description:
					"Called when the extension is registered with a player. This method handles the initial setup when the extension is registered: - Attaches to the player instance - Starts the player update loop for monitoring",
				example: "lavalinkExt.onRegister({\n  player: playerInstance\n});\n/",
				code: "lavalinkExt.onRegister({\n  player: playerInstance\n});",
				parameters: [
					{
						name: "context",
						type: "ExtensionContext",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "void",
				},
			},
			{
				name: "onDestroy",
				signature: "async onDestroy(context: ExtensionContext): Promise<void>",
				description:
					"Called when the extension is being destroyed. This method handles cleanup when the extension is destroyed: - Stops the update loop - Gracefully destroys all Lavalink players - Detaches from the current player - Closes all node connections",
				example: "await lavalinkExt.onDestroy({\n  player: playerInstance\n});\n/",
				code: "await lavalinkExt.onDestroy({\n  player: playerInstance\n});",
				parameters: [
					{
						name: "context",
						type: "ExtensionContext",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: "Promise<void>",
			},
			{
				name: "beforePlay",
				signature: "async beforePlay(context: ExtensionContext, payload: ExtensionPlayRequest): Promise<ExtensionPlayResponse>",
				description:
					"Handles play requests before they are processed by the player. This method intercepts play requests and attempts to handle them with Lavalink: - Resolves tracks using the track resolver - Adds tracks to the player's queue - Attempts to start playback on Lavalink if possible - Falls back to plugin handling if Lavalink cannot process the track",
				example:
					'const response = await lavalinkExt.beforePlay(context, {\n  query: "Never Gonna Give You Up",\n  requestedBy: "user123"\n});\nif (response.handled && response.success) {\n  console.log("Track started successfully on Lavalink");\n}\n/',
				code: 'const response = await lavalinkExt.beforePlay(context, {\n  query: "Never Gonna Give You Up",\n  requestedBy: "user123"\n});\nif (response.handled && response.success) {\n  console.log("Track started successfully on Lavalink");\n}',
				parameters: [
					{
						name: "context",
						type: "ExtensionContext",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "payload",
						type: "ExtensionPlayRequest",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "Response indicating whether the request was handled and if it was successful",
				},
			},
			{
				name: "provideSearch",
				signature:
					"async provideSearch(_context: ExtensionContext, payload: ExtensionSearchRequest): Promise<SearchResult | null>",
				description:
					"Provides search functionality for Lavalink-compatible sources. This method handles search requests by querying Lavalink nodes: - Uses the track resolver to search Lavalink sources - Supports various search prefixes and query types - Returns search results with track information",
				example:
					'const result = await lavalinkExt.provideSearch(context, {\n  query: "scsearch:Never Gonna Give You Up",\n  requestedBy: "user123"\n});\nif (result) {\n  console.log(`Found ${result.tracks.length} tracks`);\n}\n/',
				code: 'const result = await lavalinkExt.provideSearch(context, {\n  query: "scsearch:Never Gonna Give You Up",\n  requestedBy: "user123"\n});\nif (result) {\n  console.log(`Found ${result.tracks.length} tracks`);\n}',
				parameters: [
					{
						name: "_context",
						type: "ExtensionContext",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "payload",
						type: "ExtensionSearchRequest",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "Search result with tracks, or null if search failed",
				},
			},
			{
				name: "provideStream",
				signature: "async provideStream(_context: ExtensionContext, payload: ExtensionStreamRequest): Promise<StreamInfo | null>",
				description:
					"Provides stream information for Lavalink tracks. This method handles stream requests for tracks that are being played on Lavalink: - Checks if the track is currently playing on Lavalink - Verifies the track matches the requested track - Ensures the node connection is active - Returns stream metadata for Lavalink playback",
				example:
					'const streamInfo = await lavalinkExt.provideStream(context, {\n  track: trackInstance\n});\nif (streamInfo) {\n  console.log("Stream provided by Lavalink");\n}\n/',
				code: 'const streamInfo = await lavalinkExt.provideStream(context, {\n  track: trackInstance\n});\nif (streamInfo) {\n  console.log("Stream provided by Lavalink");\n}',
				parameters: [
					{
						name: "_context",
						type: "ExtensionContext",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "payload",
						type: "ExtensionStreamRequest",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "Stream info for Lavalink playback, or null if not applicable",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	speechoptions: {
		title: "SpeechOptions",
		description: "Configuration options for voice recognition and speech processing. /",
		summary: "",
		badges: ["interface", "core", "speechoptions"],
		code: "// SpeechOptions usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	pcmstream: {
		title: "PcmStream",
		description:
			"Transform stream for processing PCM audio data. This stream handles the conversion and buffering of PCM audio data for speech recognition processing. /",
		summary: "",
		badges: ["class", "core", "pcmstream"],
		code: "// PcmStream usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	voiceext: {
		title: "voiceExt",
		description:
			"Voice extension for ZiPlayer that provides real-time speech recognition. This extension enables voice-to-text functionality by: - Listening to voice activity in Discord voice channels - Converting speech to text using Google Speech API - Supporting multiple languages and custom speech resolvers - Providing real-time voice event handling - Filtering and processing audio quality",
		summary: "",
		badges: ["class", "extension", "voiceext"],
		code: 'const voiceExt = new voiceExt(null, {\n  lang: "en-US",\n  ignoreBots: true,\n  minimalVoiceMessageDuration: 1,\n  client: discordClient\n});\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  extensions: [voiceExt]\n});\n// Listen for voice events\nmanager.on("voiceCreate", (player, payload) => {\n  console.log(`${payload.userId} said: ${payload.content}`);\n});',
		methods: [
			{
				name: "active",
				signature: "active(alas: any): boolean",
				description:
					"Activates the voice extension with the provided context. This method handles the activation process: - Sets up the player and manager references - Binds the Discord client for voice events - Wraps the player's connect method to auto-attach voice handling - Attaches voice handling if already connected",
				example:
					"const success = voiceExt.active({\n  manager: playerManager,\n  client: discordClient,\n  player: playerInstance\n});\n/",
				code: "const success = voiceExt.active({\n  manager: playerManager,\n  client: discordClient,\n  player: playerInstance\n});",
				parameters: [
					{
						name: "alas",
						type: "any",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if activation was successful, `false` otherwise",
				},
			},
			{
				name: "attach",
				signature: "attach(client?: any, opts?: Partial<SpeechOptions>)",
				description:
					"Attaches voice recognition to a connected player. This method sets up voice recognition for a player that is already connected to a voice channel. It configures the speaking event handlers and sets up automatic cleanup when the player is destroyed.",
				example: 'voiceExt.attach(discordClient, {\n  lang: "en-US",\n  ignoreBots: false\n});\n/',
				code: 'voiceExt.attach(discordClient, {\n  lang: "en-US",\n  ignoreBots: false\n});',
				parameters: [
					{
						name: "client?",
						type: "any",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
					{
						name: "opts?",
						type: "Partial<SpeechOptions>",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: "void",
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	lyricsoptions: {
		title: "LyricsOptions",
		description: "Configuration options for the lyrics extension. /",
		summary: "",
		badges: ["interface", "core", "lyricsoptions"],
		code: "// LyricsOptions usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	lyricsresult: {
		title: "LyricsResult",
		description: "Result object containing lyrics information and metadata. /",
		summary: "",
		badges: ["interface", "core", "lyricsresult"],
		code: "// LyricsResult usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	lyricsext: {
		title: "lyricsExt",
		description:
			"Lyrics extension for ZiPlayer that provides automatic lyrics fetching and synchronization. This extension automatically fetches and displays lyrics for playing tracks by: - Fetching lyrics from multiple providers (LRCLIB, Lyrics.ovh) - Supporting both plain text and LRC (synchronized) lyrics - Providing real-time line-by-line updates for synced lyrics - Automatically cleaning and sanitizing track titles for better matching - Emitting events for lyrics creation and updates",
		summary: "",
		badges: ["class", "extension", "lyricsext"],
		code: 'const lyricsExt = new lyricsExt(null, {\n  provider: "lrclib",\n  includeSynced: true,\n  autoFetchOnTrackStart: true\n});\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  extensions: [lyricsExt]\n});\n// Listen for lyrics events\nmanager.on("lyricsCreate", (player, track, lyrics) => {\n  console.log(`Lyrics for ${track.title}: ${lyrics.text}`);\n});\nmanager.on("lyricsChange", (player, track, lyrics) => {\n  console.log(`Current line: ${lyrics.current}`);\n});',
		methods: [
			{
				name: "active",
				signature: "active(alas: any): boolean",
				description:
					"Activates the lyrics extension with the provided context. This method handles the activation process: - Sets up the player and manager references - Attaches track start event listeners for automatic lyrics fetching - Sets up cleanup handlers for track end and player destroy events",
				example: "const success = lyricsExt.active({\n  manager: playerManager,\n  player: playerInstance\n});\n/",
				code: "const success = lyricsExt.active({\n  manager: playerManager,\n  player: playerInstance\n});",
				parameters: [
					{
						name: "alas",
						type: "any",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if activation was successful, `false` otherwise",
				},
			},
			{
				name: "fetch",
				signature: "async fetch(track?: Track, override?: Partial<LyricsOptions>): Promise<LyricsResult | null>",
				description:
					"Fetches lyrics for a given track. This method attempts to fetch lyrics from configured providers: - First tries LRCLIB with artist and title - Falls back to LRCLIB with title only if no results - Finally tries Lyrics.ovh as a last resort - Supports both plain text and LRC (synchronized) lyrics",
				example:
					'const lyrics = await lyricsExt.fetch(track, {\n  provider: "lrclib",\n  includeSynced: true\n});\nif (lyrics) {\n  console.log(`Found ${lyrics.provider} lyrics: ${lyrics.text}`);\n  if (lyrics.synced) {\n    console.log("Synced lyrics available!");\n  }\n}\n/',
				code: 'const lyrics = await lyricsExt.fetch(track, {\n  provider: "lrclib",\n  includeSynced: true\n});\nif (lyrics) {\n  console.log(`Found ${lyrics.provider} lyrics: ${lyrics.text}`);\n  if (lyrics.synced) {\n    console.log("Synced lyrics available!");\n  }\n}',
				parameters: [
					{
						name: "track?",
						type: "Track",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
					{
						name: "override?",
						type: "Partial<LyricsOptions>",
						description: "",
						optional: true,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "Lyrics result object, or null if no lyrics found",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	pluginoptions: {
		title: "PluginOptions",
		description: "The PluginOptions interface",
		summary: "",
		badges: ["interface", "plugin", "pluginoptions"],
		code: "// PluginOptions usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
	},
	youtubeplugin: {
		title: "YouTubePlugin",
		description:
			"A plugin for handling YouTube audio content including videos, playlists, and search functionality. This plugin provides comprehensive support for: - YouTube video URLs (youtube.com, youtu.be, music.youtube.com) - YouTube playlist URLs and dynamic mixes - YouTube search queries - Audio stream extraction from YouTube videos - Related track recommendations",
		summary: "",
		badges: ["class", "plugin", "youtubeplugin"],
		code: 'const youtubePlugin = new YouTubePlugin();\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  plugins: [youtubePlugin]\n});\n// Search for videos\nconst result = await youtubePlugin.search("Never Gonna Give You Up", "user123");\n// Get audio stream\nconst stream = await youtubePlugin.getStream(result.tracks[0]);',
		methods: [
			{
				name: "canHandle",
				signature: "canHandle(query: string): boolean",
				description: "Determines if this plugin can handle the given query.",
				example:
					'plugin.canHandle("https://www.youtube.com/watch?v=dQw4w9WgXcQ"); // true\nplugin.canHandle("Never Gonna Give You Up"); // true\nplugin.canHandle("spotify:track:123"); // false\n/',
				code: 'plugin.canHandle("https://www.youtube.com/watch?v=dQw4w9WgXcQ"); // true\nplugin.canHandle("Never Gonna Give You Up"); // true\nplugin.canHandle("spotify:track:123"); // false',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the plugin can handle the query, `false` otherwise",
				},
			},
			{
				name: "validate",
				signature: "validate(url: string): boolean",
				description: "Validates if a URL is a valid YouTube URL.",
				example:
					'plugin.validate("https://www.youtube.com/watch?v=dQw4w9WgXcQ"); // true\nplugin.validate("https://youtu.be/dQw4w9WgXcQ"); // true\nplugin.validate("https://spotify.com/track/123"); // false\n/',
				code: 'plugin.validate("https://www.youtube.com/watch?v=dQw4w9WgXcQ"); // true\nplugin.validate("https://youtu.be/dQw4w9WgXcQ"); // true\nplugin.validate("https://spotify.com/track/123"); // false',
				parameters: [
					{
						name: "url",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the URL is a valid YouTube URL, `false` otherwise",
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description:
					"Searches for YouTube content based on the given query. This method handles both URL-based queries (direct video/playlist links) and text-based search queries. For URLs, it will extract video or playlist information. For text queries, it will perform a YouTube search and return up to 10 results.",
				example:
					'// Search by URL\nconst result = await plugin.search("https://www.youtube.com/watch?v=dQw4w9WgXcQ", "user123");\n// Search by text\nconst searchResult = await plugin.search("Never Gonna Give You Up", "user123");\nconsole.log(searchResult.tracks); // Array of Track objects\n/',
				code: '// Search by URL\nconst result = await plugin.search("https://www.youtube.com/watch?v=dQw4w9WgXcQ", "user123");\n// Search by text\nconst searchResult = await plugin.search("Never Gonna Give You Up", "user123");\nconsole.log(searchResult.tracks); // Array of Track objects',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A SearchResult containing tracks and optional playlist information",
				},
			},
			{
				name: "extractPlaylist",
				signature: "async extractPlaylist(url: string, requestedBy: string): Promise<Track[]>",
				description: "Extracts tracks from a YouTube playlist URL.",
				example:
					'const tracks = await plugin.extractPlaylist(\n  "https://www.youtube.com/playlist?list=PLrAXtmRdnEQy6nuLMOV8uM0bMq3MUfHc1",\n  "user123"\n);\nconsole.log(`Found ${tracks.length} tracks in playlist`);\n/',
				code: 'const tracks = await plugin.extractPlaylist(\n  "https://www.youtube.com/playlist?list=PLrAXtmRdnEQy6nuLMOV8uM0bMq3MUfHc1",\n  "user123"\n);\nconsole.log(`Found ${tracks.length} tracks in playlist`);',
				parameters: [
					{
						name: "url",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "An array of Track objects from the playlist",
				},
			},
			{
				name: "getStream",
				signature: "async getStream(track: Track): Promise<StreamInfo>",
				description:
					"Retrieves the audio stream for a YouTube track using sabr download. This method extracts the audio stream from a YouTube video using the sabr download method which provides better quality and more reliable streaming.",
				example:
					'const track = { id: "dQw4w9WgXcQ", title: "Never Gonna Give You Up", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream\n/',
				code: 'const track = { id: "dQw4w9WgXcQ", title: "Never Gonna Give You Up", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream',
				parameters: [
					{
						name: "track",
						type: "Track",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A StreamInfo object containing the audio stream and metadata",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	soundcloudplugin: {
		title: "SoundCloudPlugin",
		description:
			"A plugin for handling SoundCloud audio content including tracks, playlists, and search functionality. This plugin provides comprehensive support for: - SoundCloud track URLs (soundcloud.com) - SoundCloud playlist URLs - SoundCloud search queries - Audio stream extraction from SoundCloud tracks - Related track recommendations",
		summary: "",
		badges: ["class", "plugin", "soundcloudplugin"],
		code: 'const soundcloudPlugin = new SoundCloudPlugin();\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  plugins: [soundcloudPlugin]\n});\n// Search for tracks\nconst result = await soundcloudPlugin.search("chill music", "user123");\n// Get audio stream\nconst stream = await soundcloudPlugin.getStream(result.tracks[0]);',
		methods: [
			{
				name: "canHandle",
				signature: "canHandle(query: string): boolean",
				description: "Determines if this plugin can handle the given query.",
				example:
					'plugin.canHandle("https://soundcloud.com/artist/track"); // true\nplugin.canHandle("chill music"); // true\nplugin.canHandle("spotify:track:123"); // false\n/',
				code: 'plugin.canHandle("https://soundcloud.com/artist/track"); // true\nplugin.canHandle("chill music"); // true\nplugin.canHandle("spotify:track:123"); // false',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the plugin can handle the query, `false` otherwise",
				},
			},
			{
				name: "validate",
				signature: "validate(url: string): boolean",
				description: "Validates if a URL is a valid SoundCloud URL.",
				example:
					'plugin.validate("https://soundcloud.com/artist/track"); // true\nplugin.validate("https://www.soundcloud.com/artist/track"); // true\nplugin.validate("https://youtube.com/watch?v=123"); // false\n/',
				code: 'plugin.validate("https://soundcloud.com/artist/track"); // true\nplugin.validate("https://www.soundcloud.com/artist/track"); // true\nplugin.validate("https://youtube.com/watch?v=123"); // false',
				parameters: [
					{
						name: "url",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the URL is a valid SoundCloud URL, `false` otherwise",
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description:
					"Searches for SoundCloud content based on the given query. This method handles both URL-based queries (direct track/playlist links) and text-based search queries. For URLs, it will extract track or playlist information. For text queries, it will perform a SoundCloud search and return up to 10 results.",
				example:
					'// Search by URL\nconst result = await plugin.search("https://soundcloud.com/artist/track", "user123");\n// Search by text\nconst searchResult = await plugin.search("chill music", "user123");\nconsole.log(searchResult.tracks); // Array of Track objects\n/',
				code: '// Search by URL\nconst result = await plugin.search("https://soundcloud.com/artist/track", "user123");\n// Search by text\nconst searchResult = await plugin.search("chill music", "user123");\nconsole.log(searchResult.tracks); // Array of Track objects',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A SearchResult containing tracks and optional playlist information",
				},
			},
			{
				name: "getStream",
				signature: "async getStream(track: Track): Promise<StreamInfo>",
				description:
					"Retrieves the audio stream for a SoundCloud track. This method downloads the audio stream from SoundCloud using the track's URL. It handles the SoundCloud-specific download process and returns the stream in a format compatible with the player.",
				example:
					'const track = { id: "123", title: "Track Title", url: "https://soundcloud.com/artist/track", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream\n/',
				code: 'const track = { id: "123", title: "Track Title", url: "https://soundcloud.com/artist/track", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream',
				parameters: [
					{
						name: "track",
						type: "Track",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A StreamInfo object containing the audio stream and metadata",
				},
			},
			{
				name: "extractPlaylist",
				signature: "async extractPlaylist(url: string, requestedBy: string): Promise<Track[]>",
				description: "Extracts tracks from a SoundCloud playlist URL.",
				example:
					'const tracks = await plugin.extractPlaylist(\n  "https://soundcloud.com/artist/sets/playlist-name",\n  "user123"\n);\nconsole.log(`Found ${tracks.length} tracks in playlist`);\n/',
				code: 'const tracks = await plugin.extractPlaylist(\n  "https://soundcloud.com/artist/sets/playlist-name",\n  "user123"\n);\nconsole.log(`Found ${tracks.length} tracks in playlist`);',
				parameters: [
					{
						name: "url",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "An array of Track objects from the playlist",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	spotifyplugin: {
		title: "SpotifyPlugin",
		description:
			"A minimal Spotify plugin for metadata extraction and display purposes. This plugin provides support for: - Spotify track URLs/URIs (spotify:track:...) - Spotify playlist URLs/URIs (spotify:playlist:...) - Spotify album URLs/URIs (spotify:album:...) - Metadata extraction using Spotify's public oEmbed endpoint **Important Notes:** - This plugin does NOT provide audio streams (player is expected to redirect/fallback upstream) - This plugin does NOT expand playlists/albums (no SDK; oEmbed doesn't enumerate items) - This plugin only provides display metadata for Spotify content",
		summary: "",
		badges: ["class", "plugin", "spotifyplugin"],
		code: 'const spotifyPlugin = new SpotifyPlugin();\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  plugins: [spotifyPlugin]\n});\n// Get metadata for a Spotify track\nconst result = await spotifyPlugin.search("spotify:track:4iV5W9uYEdYUVa79Axb7Rh", "user123");\nconsole.log(result.tracks[0].metadata); // Contains Spotify metadata',
		methods: [
			{
				name: "canHandle",
				signature: "canHandle(query: string): boolean",
				description: "Determines if this plugin can handle the given query.",
				example:
					'plugin.canHandle("spotify:track:4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.canHandle("https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.canHandle("youtube.com/watch?v=123"); // false\n/',
				code: 'plugin.canHandle("spotify:track:4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.canHandle("https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.canHandle("youtube.com/watch?v=123"); // false',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the query is a Spotify URL/URI, `false` otherwise",
				},
			},
			{
				name: "validate",
				signature: "validate(url: string): boolean",
				description: "Validates if a URL/URI is a valid Spotify URL/URI.",
				example:
					'plugin.validate("spotify:track:4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.validate("https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.validate("https://youtube.com/watch?v=123"); // false\n/',
				code: 'plugin.validate("spotify:track:4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.validate("https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh"); // true\nplugin.validate("https://youtube.com/watch?v=123"); // false',
				parameters: [
					{
						name: "url",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "`true` if the URL/URI is a valid Spotify URL/URI, `false` otherwise",
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description:
					"Extracts metadata from Spotify URLs/URIs using the oEmbed API. This method handles Spotify track, playlist, and album URLs/URIs by fetching display metadata from Spotify's public oEmbed endpoint. It does not provide audio streams or expand playlists/albums.",
				example:
					'// Extract track metadata\nconst result = await plugin.search("spotify:track:4iV5W9uYEdYUVa79Axb7Rh", "user123");\nconsole.log(result.tracks[0].metadata); // Contains Spotify metadata\n// Extract playlist metadata\nconst playlistResult = await plugin.search("https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M", "user123");\nconsole.log(playlistResult.tracks[0].metadata.kind); // "playlist"\n/',
				code: '// Extract track metadata\nconst result = await plugin.search("spotify:track:4iV5W9uYEdYUVa79Axb7Rh", "user123");\nconsole.log(result.tracks[0].metadata); // Contains Spotify metadata\n// Extract playlist metadata\nconst playlistResult = await plugin.search("https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M", "user123");\nconsole.log(playlistResult.tracks[0].metadata.kind); // "playlist"',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A SearchResult containing a single track with metadata (no audio stream)",
				},
			},
			{
				name: "extractPlaylist",
				signature: "async extractPlaylist(_input: string, _requestedBy: string): Promise<Track[]>",
				description:
					"Extracts tracks from a Spotify playlist URL. **Note:** This method is not implemented as this plugin does not support playlist expansion. It always returns an empty array.",
				example:
					'const tracks = await plugin.extractPlaylist("spotify:playlist:123", "user123");\nconsole.log(tracks); // [] - empty array\n/',
				code: 'const tracks = await plugin.extractPlaylist("spotify:playlist:123", "user123");\nconsole.log(tracks); // [] - empty array',
				parameters: [
					{
						name: "_input",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "_requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "An empty array (playlist expansion not supported)",
				},
			},
			{
				name: "getStream",
				signature: "async getStream(_track: Track): Promise<StreamInfo>",
				description:
					"Attempts to get an audio stream for a Spotify track. **Note:** This method always throws an error as this plugin does not support audio streaming. The player is expected to redirect to other plugins or use fallback mechanisms for actual audio playback.",
				example:
					'try {\n  const stream = await plugin.getStream(track);\n} catch (error) {\n  console.log(error.message); // "Spotify streaming is not supported by this plugin"\n}\n/',
				code: 'try {\n  const stream = await plugin.getStream(track);\n} catch (error) {\n  console.log(error.message); // "Spotify streaming is not supported by this plugin"\n}',
				parameters: [
					{
						name: "_track",
						type: "Track",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: "Promise<StreamInfo>",
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	ttspluginoptions: {
		title: "TTSPluginOptions",
		description: "Configuration options for the TTSPlugin. /",
		summary: "",
		badges: ["interface", "plugin", "ttspluginoptions"],
		code: "// TTSPluginOptions usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	ttsconfig: {
		title: "TTSConfig",
		description: "Internal configuration for TTS processing. /",
		summary: "",
		badges: ["interface", "core", "ttsconfig"],
		code: "// TTSConfig usage example",
		methods: [],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
	ttsplugin: {
		title: "TTSPlugin",
		description:
			"A plugin for Text-to-Speech (TTS) functionality. This plugin provides support for: - Converting text to speech using Google TTS - Custom TTS providers via the createStream hook - Multiple language support - Configurable speech rate (normal/slow) - TTS query parsing with language and speed options",
		summary: "",
		badges: ["class", "plugin", "ttsplugin"],
		code: 'const ttsPlugin = new TTSPlugin({\n  defaultLang: "en",\n  slow: false\n});\n// Add to PlayerManager\nconst manager = new PlayerManager({\n  plugins: [ttsPlugin]\n});\n// Search for TTS content\nconst result = await ttsPlugin.search("tts:Hello world", "user123");\nconst stream = await ttsPlugin.getStream(result.tracks[0]);\n// Custom TTS provider\nconst customTTSPlugin = new TTSPlugin({\n  defaultLang: "en",\n  createStream: async (text, ctx) => {\n    // Custom TTS implementation\n    return customTTSProvider.synthesize(text, ctx.lang);\n  }\n});',
		methods: [
			{
				name: "canHandle",
				signature: "canHandle(query: string): boolean",
				description: "Determines if this plugin can handle the given query.",
				example:
					'plugin.canHandle("tts:Hello world"); // true\nplugin.canHandle("say Hello world"); // true\nplugin.canHandle("youtube.com/watch?v=123"); // false\n/',
				code: 'plugin.canHandle("tts:Hello world"); // true\nplugin.canHandle("say Hello world"); // true\nplugin.canHandle("youtube.com/watch?v=123"); // false',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: '`true` if the query starts with "tts:" or "say ", `false` otherwise',
				},
			},
			{
				name: "search",
				signature: "async search(query: string, requestedBy: string): Promise<SearchResult>",
				description:
					"Creates a TTS track from the given query. This method parses TTS queries and creates a track that can be played as audio. It supports various query formats including language and speed specifications.",
				example:
					'// Basic TTS\nconst result = await plugin.search("tts:Hello world", "user123");\n// TTS with specific language\nconst result2 = await plugin.search("tts:en:Hello world", "user123");\n// TTS with language and slow speed\nconst result3 = await plugin.search("tts:en:true:Hello world", "user123");\n// Using "say" prefix\nconst result4 = await plugin.search("say Hello world", "user123");\n/',
				code: '// Basic TTS\nconst result = await plugin.search("tts:Hello world", "user123");\n// TTS with specific language\nconst result2 = await plugin.search("tts:en:Hello world", "user123");\n// TTS with language and slow speed\nconst result3 = await plugin.search("tts:en:true:Hello world", "user123");\n// Using "say" prefix\nconst result4 = await plugin.search("say Hello world", "user123");',
				parameters: [
					{
						name: "query",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
					{
						name: "requestedBy",
						type: "string",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A SearchResult containing a single TTS track",
				},
			},
			{
				name: "getStream",
				signature: "async getStream(track: Track): Promise<StreamInfo>",
				description:
					"Generates an audio stream for a TTS track. This method converts the text in the track to speech using either the custom TTS provider (if configured) or the built-in Google TTS service. It handles various return types from custom providers and ensures proper stream formatting.",
				example:
					'const track = { id: "tts-123", title: "TTS: Hello world", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream with audio\n/',
				code: 'const track = { id: "tts-123", title: "TTS: Hello world", ... };\nconst streamInfo = await plugin.getStream(track);\nconsole.log(streamInfo.type); // "arbitrary"\nconsole.log(streamInfo.stream); // Readable stream with audio',
				parameters: [
					{
						name: "track",
						type: "Track",
						description: "",
						optional: false,
						default: "",
						variation: "",
					},
				],
				returns: {
					type: "any",
					description: "A StreamInfo object containing the audio stream",
				},
			},
		],
		events: [],
		properties: [],
		params: [],
		returns: null,
	},
};

export const apiContentSummary = {
	totalItems: 32,
	byType: {
		class: 11,
		interface: 21,
	},
	byModule: {
		core: 15,
		extension: 10,
		plugin: 7,
	},
	withJSDoc: 30,
	withExamples: 0,
	withReturns: 0,
	withParams: 0,
};

// Summary:
// - Total items: 32
// - Classes: 11
// - Interfaces: 21
// - Modules: 0
// - Core: 15
// - Plugins: 7
// - Extensions: 10
// - With JSDoc: 30
// - With Examples: 0
// - With @returns: 0
// - With @param: 0
