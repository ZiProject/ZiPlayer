const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

/**
 * Build script ƒë·ªÉ t·ª± ƒë·ªông sinh API documentation
 */

class ApiDocsBuilder {
	constructor() {
		this.rootDir = path.resolve(__dirname, "../..");
		this.scriptsDir = path.resolve(__dirname, ".");
	}

	/**
	 * Ch·∫°y t·∫•t c·∫£ c√°c b∆∞·ªõc build
	 */
	async build() {
		console.log("üöÄ Building API Documentation...\n");

		try {
			// B∆∞·ªõc 1: Generate API content t·ª´ code (ch·ªâ ƒë·ªçc JSDoc c√≥ s·∫µn)
			console.log("üîß Step 1: Generating API content from existing JSDoc...");
			execSync(`node ${path.join(this.scriptsDir, "generateApiContent.js")}`, { stdio: "inherit" });
			console.log("‚úÖ API content generated\n");

			// B∆∞·ªõc 2: Merge v·ªõi manual content
			console.log("üîó Step 2: Merging with manual content...");
			this.mergeWithManualContent();
			console.log("‚úÖ Content merged\n");

			// B∆∞·ªõc 3: Validate v√† format
			console.log("‚úÖ Step 3: Validating and formatting...");
			this.validateAndFormat();
			console.log("‚úÖ Documentation built successfully!\n");

			console.log("üéâ API Documentation build completed!");
			console.log("üìÅ Generated files:");
			console.log("   - page/components/GeneratedApiContent.ts");
			console.log("   - page/components/ApiContent.tsx (updated)");
		} catch (error) {
			console.error("‚ùå Build failed:", error.message);
			process.exit(1);
		}
	}

	/**
	 * Merge generated content v·ªõi manual content
	 */
	mergeWithManualContent() {
		const generatedPath = path.join(this.rootDir, "page/components/GeneratedApiContent.ts");
		const manualPath = path.join(this.rootDir, "page/components/ApiContent.tsx");

		if (!fs.existsSync(generatedPath)) {
			console.warn("‚ö†Ô∏è  Generated content not found, skipping merge");
			return;
		}

		// ƒê·ªçc generated content
		const generatedContent = fs.readFileSync(generatedPath, "utf8");
		const generatedMatch = generatedContent.match(/export const generatedApiContent = ({[\s\S]*});/);

		if (!generatedMatch) {
			console.warn("‚ö†Ô∏è  Could not parse generated content");
			return;
		}

		const generatedApiContent = JSON.parse(generatedMatch[1]);

		// ƒê·ªçc manual content
		const manualContent = fs.readFileSync(manualPath, "utf8");
		const manualMatch = manualContent.match(/const apiContent = ({[\s\S]*});/);

		if (!manualMatch) {
			console.warn("‚ö†Ô∏è  Could not parse manual content");
			return;
		}

		let manualApiContent;
		try {
			manualApiContent = JSON.parse(manualMatch[1]);
		} catch (error) {
			console.warn("‚ö†Ô∏è  Could not parse manual content JSON:", error.message);
			return;
		}

		// Merge content (manual overrides generated)
		const mergedContent = {
			...generatedApiContent,
			...manualApiContent,
		};

		// T·∫°o merged content string
		const mergedString = `// Auto-generated API content merged with manual content
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually - it will be overwritten

export const apiContent = ${JSON.stringify(mergedContent, null, 2)};

// Manual overrides (these will override generated content)
export const manualOverrides = ${JSON.stringify(manualApiContent, null, 2)};
`;

		// L∆∞u merged content
		fs.writeFileSync(generatedPath, mergedString);
		console.log("‚úÖ Content merged successfully");
	}

	/**
	 * Validate v√† format content
	 */
	validateAndFormat() {
		const generatedPath = path.join(this.rootDir, "page/components/GeneratedApiContent.ts");

		if (!fs.existsSync(generatedPath)) {
			console.warn("‚ö†Ô∏è  Generated content not found for validation");
			return;
		}

		try {
			// Validate JSON structure
			const content = fs.readFileSync(generatedPath, "utf8");
			const match = content.match(/export const apiContent = ({[\s\S]*});/);

			if (match) {
				const apiContent = JSON.parse(match[1]);

				// Validate required fields
				const requiredFields = ["title", "description", "badges", "code"];
				let isValid = true;

				for (const [key, value] of Object.entries(apiContent)) {
					if (typeof value !== "object" || value === null) {
						console.warn(`‚ö†Ô∏è  Invalid content for ${key}: not an object`);
						isValid = false;
						continue;
					}

					for (const field of requiredFields) {
						if (!(field in value)) {
							console.warn(`‚ö†Ô∏è  Missing required field '${field}' in ${key}`);
							isValid = false;
						}
					}
				}

				if (isValid) {
					console.log("‚úÖ Content validation passed");
				} else {
					console.warn("‚ö†Ô∏è  Content validation failed - check warnings above");
				}
			}
		} catch (error) {
			console.error("‚ùå Validation failed:", error.message);
		}
	}

	/**
	 * Watch mode - t·ª± ƒë·ªông rebuild khi c√≥ thay ƒë·ªïi
	 */
	watch() {
		console.log("üëÄ Starting watch mode...");
		console.log("üìÅ Watching files in core/, extension/, plugins/");

		const chokidar = require("chokidar");

		const watcher = chokidar.watch(
			[
				path.join(this.rootDir, "core/src/**/*.ts"),
				path.join(this.rootDir, "extension/src/**/*.ts"),
				path.join(this.rootDir, "plugins/src/**/*.ts"),
			],
			{
				ignored: /node_modules/,
				persistent: true,
			},
		);

		let isBuilding = false;

		watcher.on("change", async (filePath) => {
			if (isBuilding) return;

			console.log(`\nüìù File changed: ${path.relative(this.rootDir, filePath)}`);
			isBuilding = true;

			try {
				await this.build();
			} catch (error) {
				console.error("‚ùå Watch build failed:", error.message);
			} finally {
				isBuilding = false;
			}
		});

		console.log("‚úÖ Watch mode started. Press Ctrl+C to stop.");
	}
}

// CLI interface
if (require.main === module) {
	const builder = new ApiDocsBuilder();
	const command = process.argv[2];

	switch (command) {
		case "build":
			builder.build();
			break;
		case "watch":
			builder.watch();
			break;
		default:
			console.log("Usage: node buildApiDocs.js [build|watch]");
			console.log("  build - Build API documentation once");
			console.log("  watch - Build and watch for changes");
			process.exit(1);
	}
}

module.exports = ApiDocsBuilder;
